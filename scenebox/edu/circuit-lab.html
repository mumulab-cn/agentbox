<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°å­¦ç”Ÿç”µè·¯å®éªŒå®¤ - æ‹–æ‹½å¼ç”µè·¯æ­å»º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .main-content {
            display: flex;
            height: 80vh;
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 2px solid #e9ecef;
            padding: 20px;
            overflow-y: auto;
        }

        .component-library {
            margin-bottom: 30px;
        }

        .component-library h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .component-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .component-item {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: grab;
            transition: all 0.3s ease;
            user-select: none;
        }

        .component-item:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,123,255,0.3);
        }

        .component-item.selected {
            border-color: #28a745;
            background: #d4edda;
        }

        .component-icon {
            font-size: 2em;
            margin-bottom: 5px;
            display: block;
        }

        .workspace {
            flex: 1;
            background: #ffffff;
            position: relative;
            overflow: hidden;
        }

        .workspace-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        .placed-component {
            position: absolute;
            width: 60px;
            height: 60px;
            background: white;
            border: 2px solid #007bff;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: transform 0.1s ease;
        }

        .placed-component:hover {
            transform: scale(1.05);
            border-color: #0056b3;
        }

        .placed-component:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .placed-component.battery {
            background: #ffeaa7;
            border-color: #fdcb6e;
        }

        .placed-component.bulb {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .placed-component.bulb.on {
            background: #ffeb3b;
            box-shadow: 0 0 20px #ffeb3b;
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 20px #ffeb3b; }
            to { box-shadow: 0 0 30px #ffeb3b, 0 0 40px #ffeb3b; }
        }

        .placed-component.switch {
            background: #e17055;
            border-color: #d63031;
        }

        .placed-component.switch.on {
            background: #00b894;
            border-color: #00a085;
        }

        .wire {
            position: absolute;
            background: #007bff;
            z-index: 5;
            border-radius: 2px;
        }

        .wire.horizontal {
            height: 4px;
        }

        .wire.vertical {
            width: 4px;
        }

        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #dc3545;
            border-radius: 50%;
            z-index: 15;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connection-point:hover {
            transform: scale(1.3);
            background: #28a745;
        }

        .connection-point.connected {
            background: #28a745;
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-top: 2px solid #e9ecef;
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .status-panel {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border-left: 5px solid #007bff;
        }

        .status-panel h4 {
            color: #495057;
            margin-bottom: 10px;
        }

        .status-text {
            font-size: 1.1em;
            font-weight: bold;
        }

        .status-text.success {
            color: #28a745;
        }

        .status-text.error {
            color: #dc3545;
        }

        .suggestions {
            margin-top: 15px;
            padding: 10px;
            background: #fff3cd;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
        }

        .suggestions h5 {
            color: #856404;
            margin-bottom: 8px;
        }

        .suggestions ul {
            color: #856404;
            margin-left: 20px;
        }

        .circuit-info {
            margin-bottom: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 10px;
            border-left: 5px solid #2196f3;
        }

        .circuit-info h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .mode-selector {
            margin-bottom: 20px;
        }

        .mode-selector label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #495057;
        }

        .mode-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            font-size: 1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¬ å°å­¦ç”Ÿç”µè·¯å®éªŒå®¤</h1>
            <p>æ‹–æ‹½å…ƒä»¶ï¼Œæ­å»ºç”µè·¯ï¼Œè®©ä¸¤ä¸ªå°ç¯æ³¡å‘å…‰ï¼</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="circuit-info">
                    <h4>ğŸ“š å­¦ä¹ ç›®æ ‡</h4>
                    <p>é€šè¿‡æ‹–æ‹½ç”µå­å…ƒä»¶ï¼Œå­¦ä¹ ä¸²è”å’Œå¹¶è”ç”µè·¯çš„æ­å»ºï¼Œè§‚å¯Ÿä¸¤ä¸ªå°ç¯æ³¡çš„å‘å…‰æ•ˆæœã€‚</p>
                </div>

                <div class="mode-selector">
                    <label for="circuitMode">é€‰æ‹©ç”µè·¯ç±»å‹ï¼š</label>
                    <select id="circuitMode">
                        <option value="series">ä¸²è”ç”µè·¯</option>
                        <option value="parallel">å¹¶è”ç”µè·¯</option>
                        <option value="mixed">æ··åˆç”µè·¯</option>
                    </select>
                </div>

                <div class="component-library">
                    <h3>ğŸ”§ ç”µå­å…ƒä»¶åº“</h3>
                    <div class="component-grid">
                        <div class="component-item" data-type="battery">
                            <span class="component-icon">ğŸ”‹</span>
                            <div>ç”µæ± </div>
                        </div>
                        <div class="component-item" data-type="bulb">
                            <span class="component-icon">ğŸ’¡</span>
                            <div>ç¯æ³¡</div>
                        </div>
                        <div class="component-item" data-type="switch">
                            <span class="component-icon">ğŸ”˜</span>
                            <div>å¼€å…³</div>
                        </div>
                        <div class="component-item" data-type="wire">
                            <span class="component-icon">â–</span>
                            <div>å¯¼çº¿</div>
                        </div>
                    </div>
                </div>

                <div class="status-panel">
                    <h4>ğŸ“Š ç”µè·¯çŠ¶æ€</h4>
                    <div id="circuitStatus" class="status-text">è¯·å¼€å§‹æ­å»ºç”µè·¯</div>
                    <div id="bulbCount">ç¯æ³¡æ•°é‡: 0/2</div>
                    <div id="connectionStatus">è¿æ¥çŠ¶æ€: æœªè¿æ¥</div>
                </div>

                <div id="suggestions" class="suggestions" style="display: none;">
                    <h5>ğŸ’¡ ä¿®æ”¹å»ºè®®</h5>
                    <ul id="suggestionList"></ul>
                </div>
            </div>

            <div class="workspace" id="workspace">
                <div class="workspace-grid"></div>
            </div>
        </div>

        <div class="controls">
            <div class="control-buttons">
                <button class="btn btn-primary" onclick="testCircuit()">ğŸ” æµ‹è¯•ç”µè·¯</button>
                <button class="btn btn-success" onclick="autoConnect()">ğŸ”— è‡ªåŠ¨è¿çº¿</button>
                <button class="btn btn-warning" onclick="showHint()">ğŸ’¡ è·å–æç¤º</button>
                <button class="btn btn-danger" onclick="clearWorkspace()">ğŸ—‘ï¸ æ¸…ç©ºå·¥ä½œå°</button>
            </div>
        </div>
    </div>

    <script>
        let selectedComponent = null;
        let placedComponents = [];
        let connections = [];
        let isConnecting = false;
        let connectionStart = null;
        let componentCounter = 0;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeWorkspace();
            updateStatus();
        });

        function initializeWorkspace() {
            const workspace = document.getElementById('workspace');
            const componentItems = document.querySelectorAll('.component-item');

            // å…ƒä»¶é€‰æ‹©
            componentItems.forEach(item => {
                item.addEventListener('click', function() {
                    // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
                    componentItems.forEach(i => i.classList.remove('selected'));
                    // é€‰æ‹©å½“å‰å…ƒä»¶
                    this.classList.add('selected');
                    selectedComponent = this.dataset.type;
                });
            });

            // å·¥ä½œåŒºç‚¹å‡»æ”¾ç½®å…ƒä»¶
            workspace.addEventListener('click', function(e) {
                if (selectedComponent && e.target === workspace) {
                    placeComponent(e.offsetX, e.offsetY, selectedComponent);
                }
            });
        }

        function placeComponent(x, y, type) {
            // ç½‘æ ¼å¯¹é½
            const gridSize = 30;
            const alignedX = Math.round(x / gridSize) * gridSize;
            const alignedY = Math.round(y / gridSize) * gridSize;

            const component = {
                id: ++componentCounter,
                type: type,
                x: alignedX,
                y: alignedY,
                connections: [],
                state: type === 'switch' ? false : null
            };

            placedComponents.push(component);
            renderComponent(component);
            updateStatus();
        }

        function renderComponent(component) {
            const workspace = document.getElementById('workspace');
            const element = document.createElement('div');
            element.className = `placed-component ${component.type}`;
            element.style.left = component.x + 'px';
            element.style.top = component.y + 'px';
            element.dataset.id = component.id;

            // è®¾ç½®å›¾æ ‡
            const icons = {
                battery: 'ğŸ”‹',
                bulb: 'ğŸ’¡',
                switch: 'ğŸ”˜',
                wire: 'â–'
            };
            element.innerHTML = icons[component.type];

            // æ·»åŠ è¿æ¥ç‚¹
            if (component.type !== 'wire') {
                addConnectionPoints(element, component);
            }

            // å¼€å…³ç‚¹å‡»äº‹ä»¶
            if (component.type === 'switch') {
                element.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleSwitch(component.id);
                });
            }

            // æ‹–æ‹½åŠŸèƒ½
            makeDraggable(element, component);

            workspace.appendChild(element);
        }

        function addConnectionPoints(element, component) {
            const points = [
                { x: -6, y: 24 }, // å·¦
                { x: 54, y: 24 }, // å³
                { x: 24, y: -6 }, // ä¸Š
                { x: 24, y: 54 }  // ä¸‹
            ];

            points.forEach((point, index) => {
                const connectionPoint = document.createElement('div');
                connectionPoint.className = 'connection-point';
                connectionPoint.style.left = point.x + 'px';
                connectionPoint.style.top = point.y + 'px';
                connectionPoint.dataset.componentId = component.id;
                connectionPoint.dataset.pointIndex = index;

                connectionPoint.addEventListener('click', function(e) {
                    e.stopPropagation();
                    handleConnectionClick(component.id, index);
                });

                element.appendChild(connectionPoint);
            });
        }

        function handleConnectionClick(componentId, pointIndex) {
            if (!isConnecting) {
                // å¼€å§‹è¿æ¥
                isConnecting = true;
                connectionStart = { componentId, pointIndex };
                updateConnectionPointStyles();
            } else {
                // å®Œæˆè¿æ¥
                if (connectionStart.componentId !== componentId) {
                    createConnection(connectionStart, { componentId, pointIndex });
                }
                isConnecting = false;
                connectionStart = null;
                updateConnectionPointStyles();
            }
        }

        function createConnection(start, end) {
            const connection = {
                id: Date.now(),
                start: start,
                end: end
            };

            connections.push(connection);
            renderConnection(connection);
            updateStatus();
        }

        function renderConnection(connection) {
            const workspace = document.getElementById('workspace');
            const startComponent = placedComponents.find(c => c.id == connection.start.componentId);
            const endComponent = placedComponents.find(c => c.id == connection.end.componentId);

            if (!startComponent || !endComponent) return;

            const startPos = getConnectionPointPosition(startComponent, connection.start.pointIndex);
            const endPos = getConnectionPointPosition(endComponent, connection.end.pointIndex);

            // åˆ›å»ºå¯¼çº¿
            const wire = document.createElement('div');
            wire.className = 'wire';
            wire.dataset.connectionId = connection.id;

            const deltaX = endPos.x - startPos.x;
            const deltaY = endPos.y - startPos.y;
            const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;

            wire.style.left = startPos.x + 'px';
            wire.style.top = startPos.y + 'px';
            wire.style.width = length + 'px';
            wire.style.height = '4px';
            wire.style.transform = `rotate(${angle}deg)`;
            wire.style.transformOrigin = '0 50%';

            workspace.appendChild(wire);
        }

        function getConnectionPointPosition(component, pointIndex) {
            const points = [
                { x: component.x - 6, y: component.y + 24 }, // å·¦
                { x: component.x + 54, y: component.y + 24 }, // å³
                { x: component.x + 24, y: component.y - 6 }, // ä¸Š
                { x: component.x + 24, y: component.y + 54 }  // ä¸‹
            ];
            return points[pointIndex];
        }

        function updateConnectionPointStyles() {
            const points = document.querySelectorAll('.connection-point');
            points.forEach(point => {
                if (isConnecting) {
                    point.style.background = '#28a745';
                    point.style.transform = 'scale(1.2)';
                } else {
                    point.style.background = '#dc3545';
                    point.style.transform = 'scale(1)';
                }
            });
        }

        function toggleSwitch(componentId) {
            const component = placedComponents.find(c => c.id == componentId);
            if (component && component.type === 'switch') {
                component.state = !component.state;
                const element = document.querySelector(`[data-id="${componentId}"]`);
                if (component.state) {
                    element.classList.add('on');
                } else {
                    element.classList.remove('on');
                }
                updateStatus();
            }
        }

        function testCircuit() {
            const analysis = analyzeCircuit();
            updateCircuitVisualization(analysis);
            showSuggestions(analysis);
        }

        function analyzeCircuit() {
            const batteries = placedComponents.filter(c => c.type === 'battery');
            const bulbs = placedComponents.filter(c => c.type === 'bulb');
            const switches = placedComponents.filter(c => c.type === 'switch');

            const analysis = {
                hasBattery: batteries.length > 0,
                bulbCount: bulbs.length,
                hasRequiredBulbs: bulbs.length >= 2,
                switchesOn: switches.filter(s => s.state).length,
                totalSwitches: switches.length,
                isComplete: false,
                circuitType: document.getElementById('circuitMode').value,
                suggestions: []
            };

            // æ£€æŸ¥ç”µè·¯å®Œæ•´æ€§
            if (analysis.hasBattery && analysis.hasRequiredBulbs) {
                // ç®€åŒ–çš„ç”µè·¯åˆ†æ - æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„è¿æ¥
                const totalConnections = connections.length;
                const requiredConnections = Math.max(3, bulbs.length + 1); // æœ€å°‘éœ€è¦çš„è¿æ¥æ•°

                if (totalConnections >= requiredConnections) {
                    // æ£€æŸ¥å¼€å…³çŠ¶æ€
                    const allSwitchesOn = switches.length === 0 || switches.every(s => s.state);
                    analysis.isComplete = allSwitchesOn;
                }
            }

            // ç”Ÿæˆå»ºè®®
            if (!analysis.hasBattery) {
                analysis.suggestions.push('éœ€è¦æ·»åŠ ç”µæ± ä½œä¸ºç”µæº');
            }
            if (analysis.bulbCount < 2) {
                analysis.suggestions.push(`éœ€è¦æ·»åŠ ${2 - analysis.bulbCount}ä¸ªç¯æ³¡`);
            }
            if (connections.length < 3) {
                analysis.suggestions.push('éœ€è¦ç”¨å¯¼çº¿è¿æ¥å„ä¸ªå…ƒä»¶');
            }
            if (switches.some(s => !s.state)) {
                analysis.suggestions.push('è¯·æ‰“å¼€æ‰€æœ‰å¼€å…³');
            }
            if (analysis.isComplete) {
                analysis.suggestions.push('ç”µè·¯æ­å»ºå®Œæˆï¼ä¸¤ä¸ªç¯æ³¡éƒ½ä¼šå‘å…‰ï¼');
            }

            return analysis;
        }

        function updateCircuitVisualization(analysis) {
            const bulbs = document.querySelectorAll('.placed-component.bulb');
            bulbs.forEach(bulb => {
                if (analysis.isComplete) {
                    bulb.classList.add('on');
                } else {
                    bulb.classList.remove('on');
                }
            });
        }

        function showSuggestions(analysis) {
            const suggestionsDiv = document.getElementById('suggestions');
            const suggestionList = document.getElementById('suggestionList');

            if (analysis.suggestions.length > 0) {
                suggestionList.innerHTML = '';
                analysis.suggestions.forEach(suggestion => {
                    const li = document.createElement('li');
                    li.textContent = suggestion;
                    suggestionList.appendChild(li);
                });
                suggestionsDiv.style.display = 'block';
            } else {
                suggestionsDiv.style.display = 'none';
            }
        }

        function updateStatus() {
            const analysis = analyzeCircuit();
            const statusElement = document.getElementById('circuitStatus');
            const bulbCountElement = document.getElementById('bulbCount');
            const connectionStatusElement = document.getElementById('connectionStatus');

            // æ›´æ–°çŠ¶æ€æ–‡æœ¬
            if (analysis.isComplete) {
                statusElement.textContent = 'ç”µè·¯è¿é€š - ç¯æ³¡å‘å…‰ï¼';
                statusElement.className = 'status-text success';
            } else {
                statusElement.textContent = 'ç”µè·¯æœªå®Œæˆ';
                statusElement.className = 'status-text error';
            }

            bulbCountElement.textContent = `ç¯æ³¡æ•°é‡: ${analysis.bulbCount}/2`;
            connectionStatusElement.textContent = `è¿æ¥æ•°é‡: ${connections.length}`;
        }

        function autoConnect() {
            const circuitMode = document.getElementById('circuitMode').value;
            const batteries = placedComponents.filter(c => c.type === 'battery');
            const bulbs = placedComponents.filter(c => c.type === 'bulb');

            if (batteries.length > 0 && bulbs.length >= 2) {
                // æ¸…é™¤ç°æœ‰è¿æ¥
                connections = [];
                document.querySelectorAll('.wire').forEach(wire => wire.remove());

                // æ ¹æ®ç”µè·¯ç±»å‹è‡ªåŠ¨è¿æ¥
                if (circuitMode === 'series') {
                    createSeriesCircuit(batteries[0], bulbs.slice(0, 2));
                } else if (circuitMode === 'parallel') {
                    createParallelCircuit(batteries[0], bulbs.slice(0, 2));
                }

                updateStatus();
            } else {
                alert('è¯·å…ˆæ”¾ç½®1ä¸ªç”µæ± å’Œè‡³å°‘2ä¸ªç¯æ³¡ï¼');
            }
        }

        function createSeriesCircuit(battery, bulbs) {
            // ä¸²è”ç”µè·¯ï¼šç”µæ±  -> ç¯æ³¡1 -> ç¯æ³¡2 -> ç”µæ± 
            if (bulbs.length >= 2) {
                createConnection(
                    { componentId: battery.id, pointIndex: 1 },
                    { componentId: bulbs[0].id, pointIndex: 0 }
                );
                createConnection(
                    { componentId: bulbs[0].id, pointIndex: 1 },
                    { componentId: bulbs[1].id, pointIndex: 0 }
                );
                createConnection(
                    { componentId: bulbs[1].id, pointIndex: 1 },
                    { componentId: battery.id, pointIndex: 0 }
                );
            }
        }

        function createParallelCircuit(battery, bulbs) {
            // å¹¶è”ç”µè·¯ï¼šç”µæ± åˆ†åˆ«è¿æ¥ä¸¤ä¸ªç¯æ³¡
            if (bulbs.length >= 2) {
                createConnection(
                    { componentId: battery.id, pointIndex: 1 },
                    { componentId: bulbs[0].id, pointIndex: 0 }
                );
                createConnection(
                    { componentId: battery.id, pointIndex: 1 },
                    { componentId: bulbs[1].id, pointIndex: 0 }
                );
                createConnection(
                    { componentId: bulbs[0].id, pointIndex: 1 },
                    { componentId: battery.id, pointIndex: 0 }
                );
                createConnection(
                    { componentId: bulbs[1].id, pointIndex: 1 },
                    { componentId: battery.id, pointIndex: 0 }
                );
            }
        }

        function showHint() {
            const circuitMode = document.getElementById('circuitMode').value;
            let hint = '';

            if (circuitMode === 'series') {
                hint = 'ä¸²è”ç”µè·¯æç¤ºï¼š\n1. æ”¾ç½®1ä¸ªç”µæ± å’Œ2ä¸ªç¯æ³¡\n2. ç”¨å¯¼çº¿å°†å®ƒä»¬ä¾æ¬¡è¿æ¥æˆä¸€ä¸ªå›è·¯\n3. ç”µæµä¼šä¾æ¬¡é€šè¿‡æ¯ä¸ªå…ƒä»¶';
            } else if (circuitMode === 'parallel') {
                hint = 'å¹¶è”ç”µè·¯æç¤ºï¼š\n1. æ”¾ç½®1ä¸ªç”µæ± å’Œ2ä¸ªç¯æ³¡\n2. å°†ä¸¤ä¸ªç¯æ³¡åˆ†åˆ«è¿æ¥åˆ°ç”µæ± çš„ä¸¤ç«¯\n3. æ¯ä¸ªç¯æ³¡éƒ½æœ‰ç‹¬ç«‹çš„å›è·¯';
            } else {
                hint = 'æ··åˆç”µè·¯æç¤ºï¼š\n1. å¯ä»¥ç»“åˆä¸²è”å’Œå¹¶è”çš„ç‰¹ç‚¹\n2. å°è¯•ä¸åŒçš„è¿æ¥æ–¹å¼\n3. è§‚å¯Ÿç¯æ³¡çš„äº®åº¦å˜åŒ–';
            }

            alert(hint);
        }

        function clearWorkspace() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºå·¥ä½œå°å—ï¼Ÿ')) {
                placedComponents = [];
                connections = [];
                componentCounter = 0;
                
                const workspace = document.getElementById('workspace');
                const components = workspace.querySelectorAll('.placed-component, .wire');
                components.forEach(component => component.remove());
                
                updateStatus();
                document.getElementById('suggestions').style.display = 'none';
            }
        }

        function makeDraggable(element, component) {
            let isDragging = false;
            let startX, startY, initialX, initialY;
            let dragOffset = { x: 0, y: 0 };

            element.addEventListener('mousedown', function(e) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯è¿æ¥ç‚¹ï¼Œä¸å¯åŠ¨æ‹–æ‹½
                if (e.target.classList.contains('connection-point')) return;
                
                isDragging = true;
                
                // è·å–é¼ æ ‡ç›¸å¯¹äºå·¥ä½œåŒºçš„ä½ç½®
                const workspace = document.getElementById('workspace');
                const workspaceRect = workspace.getBoundingClientRect();
                
                startX = e.clientX - workspaceRect.left;
                startY = e.clientY - workspaceRect.top;
                initialX = component.x;
                initialY = component.y;
                
                // è®¡ç®—é¼ æ ‡ç›¸å¯¹äºå…ƒä»¶çš„åç§»
                dragOffset.x = startX - component.x;
                dragOffset.y = startY - component.y;
                
                element.style.cursor = 'grabbing';
                element.style.zIndex = '1000';
                e.preventDefault();
                e.stopPropagation();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;

                // è·å–é¼ æ ‡ç›¸å¯¹äºå·¥ä½œåŒºçš„ä½ç½®
                const workspace = document.getElementById('workspace');
                const workspaceRect = workspace.getBoundingClientRect();
                
                const mouseX = e.clientX - workspaceRect.left;
                const mouseY = e.clientY - workspaceRect.top;
                
                // è®¡ç®—æ–°ä½ç½®ï¼ˆå‡å»åç§»é‡ï¼‰
                let newX = mouseX - dragOffset.x;
                let newY = mouseY - dragOffset.y;
                
                // è¾¹ç•Œæ£€æŸ¥
                const workspaceWidth = workspace.offsetWidth;
                const workspaceHeight = workspace.offsetHeight;
                const elementWidth = 60;
                const elementHeight = 60;
                
                newX = Math.max(0, Math.min(newX, workspaceWidth - elementWidth));
                newY = Math.max(0, Math.min(newY, workspaceHeight - elementHeight));
                
                // ç½‘æ ¼å¯¹é½
                const gridSize = 30;
                component.x = Math.round(newX / gridSize) * gridSize;
                component.y = Math.round(newY / gridSize) * gridSize;
                
                element.style.left = component.x + 'px';
                element.style.top = component.y + 'px';
                
                // æ›´æ–°è¿æ¥çº¿
                updateConnections();
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    element.style.cursor = 'grab';
                    element.style.zIndex = '10';
                }
            });
            
            // æ·»åŠ è§¦æ‘¸æ”¯æŒï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
            element.addEventListener('touchstart', function(e) {
                if (e.target.classList.contains('connection-point')) return;
                
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                element.dispatchEvent(mouseEvent);
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                document.dispatchEvent(mouseEvent);
                e.preventDefault();
            });
            
            document.addEventListener('touchend', function(e) {
                if (isDragging) {
                    const mouseEvent = new MouseEvent('mouseup', {});
                    document.dispatchEvent(mouseEvent);
                }
            });
        }

        function updateConnections() {
            connections.forEach(connection => {
                const wireElement = document.querySelector(`[data-connection-id="${connection.id}"]`);
                if (wireElement) {
                    wireElement.remove();
                    renderConnection(connection);
                }
            });
        }
    </script>
</body>
</html>