<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åº·ä¹çƒæ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #gameCanvas {
            border: 12px solid #654321;
            border-radius: 15px;
            background: #0f5132;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.4);
            cursor: crosshair;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            color: white;
            font-size: 16px;
        }
        
        .score-board {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin: 0 10px;
        }
        
        .power-bar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 10px;
            margin: 10px auto;
            position: relative;
            overflow: hidden;
        }
        
        .power-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            width: 0%;
            transition: width 0.1s;
        }
        
        .controls {
            margin-top: 15px;
            color: white;
        }
        
        button {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        button:hover {
            background: #c0392b;
        }
        
        .target-ball {
            color: #f39c12;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ± åº·ä¹çƒæ¸¸æˆ (Snooker)</h1>
        <canvas id="gameCanvas" width="900" height="450"></canvas>
        
        <div class="game-info">
            <div class="score-board">
                <div>ç©å®¶å¾—åˆ†: <span id="playerScore">0</span></div>
                <div>ç›®æ ‡çƒ: <span id="targetBall" class="target-ball">çº¢çƒ</span></div>
            </div>
            <div class="score-board">
                <div>çº¢çƒå‰©ä½™: <span id="redBalls">15</span></div>
                <div>å›åˆ: <span id="currentPlayer">ç©å®¶</span></div>
            </div>
        </div>
        
        <div class="controls">
            <p>ç‚¹å‡»å¹¶æ‹–æ‹½ç™½çƒæ¥ç„å‡†ï¼Œæ¾å¼€é¼ æ ‡å‡»çƒ</p>
            <div class="power-bar">
                <div class="power-fill" id="powerFill"></div>
            </div>
            <p>åŠ›åº¦: <span id="powerText">0</span>%</p>
            <button onclick="resetGame()">é‡æ–°å¼€å§‹</button>
            <button onclick="showRules()">æ¸¸æˆè§„åˆ™</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const powerFill = document.getElementById('powerFill');
        const powerText = document.getElementById('powerText');
        
        // æ¸¸æˆçŠ¶æ€
        let isAiming = false;
        let aimStartX = 0;
        let aimStartY = 0;
        let power = 0;
        let playerScore = 0;
        let targetBall = 'red'; // 'red' or color name
        let gamePhase = 'red'; // 'red' or 'color'
        
        // çƒçš„ç±»
        class Ball {
            constructor(x, y, radius, color, points = 0, type = 'colored') {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = radius;
                this.color = color;
                this.points = points;
                this.type = type; // 'cue', 'red', 'colored'
                this.friction = 0.985;
                this.active = true;
            }
            
            update() {
                if (!this.active) return;
                
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;
                
                // è¾¹ç•Œç¢°æ’
                if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) {
                    this.vx = -this.vx * 0.8;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                if (this.y - this.radius <= 0 || this.y + this.radius >= canvas.height) {
                    this.vy = -this.vy * 0.8;
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
                }
                
                // åœæ­¢å¾®å°è¿åŠ¨
                if (Math.abs(this.vx) < 0.1) this.vx = 0;
                if (Math.abs(this.vy) < 0.1) this.vy = 0;
            }
            
            draw() {
                if (!this.active) return;
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = this.type === 'cue' ? '#333' : '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç™½çƒç‰¹æ®Šæ ‡è®°
                if (this.type === 'cue') {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.3, 0, Math.PI * 2);
                    ctx.fillStyle = '#333';
                    ctx.fill();
                }
            }
            
            isMoving() {
                return Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1;
            }
        }
        
        // åˆå§‹åŒ–çƒ
        let balls = [];
        let cueBall;
        
        function initBalls() {
            balls = [];
            
            // ç™½çƒï¼ˆä¸»çƒï¼‰
            cueBall = new Ball(200, 225, 12, 'white', 0, 'cue');
            balls.push(cueBall);
            
            // 15ä¸ªçº¢çƒï¼ˆä¸‰è§’å½¢æ’åˆ—ï¼‰
            let redIndex = 0;
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col <= row && redIndex < 15; col++) {
                    const x = 650 + row * 20;
                    const y = 225 + (col - row/2) * 24;
                    balls.push(new Ball(x, y, 12, '#dc143c', 1, 'red'));
                    redIndex++;
                }
            }
            
            // 6ä¸ªå½©çƒ
            const coloredBalls = [
                {x: 750, y: 225, color: '#000000', points: 7, name: 'é»‘çƒ'}, // é»‘çƒ
                {x: 720, y: 225, color: '#ff69b4', points: 6, name: 'ç²‰çƒ'}, // ç²‰çƒ
                {x: 690, y: 225, color: '#0000ff', points: 5, name: 'è“çƒ'}, // è“çƒ
                {x: 450, y: 225, color: '#8b4513', points: 4, name: 'æ£•çƒ'}, // æ£•çƒ
                {x: 450, y: 180, color: '#008000', points: 3, name: 'ç»¿çƒ'}, // ç»¿çƒ
                {x: 450, y: 270, color: '#ffff00', points: 2, name: 'é»„çƒ'}  // é»„çƒ
            ];
            
            coloredBalls.forEach(ball => {
                balls.push(new Ball(ball.x, ball.y, 12, ball.color, ball.points, 'colored'));
            });
        }
        
        // çƒä¸çƒç¢°æ’æ£€æµ‹
        function checkCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const ball1 = balls[i];
                    const ball2 = balls[j];
                    
                    if (!ball1.active || !ball2.active) continue;
                    
                    const dx = ball2.x - ball1.x;
                    const dy = ball2.y - ball1.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < ball1.radius + ball2.radius) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆå‡»çƒ
                        if (ball1.type === 'cue' && ball1.isMoving()) {
                            checkValidShot(ball2);
                        } else if (ball2.type === 'cue' && ball2.isMoving()) {
                            checkValidShot(ball1);
                        }
                        
                        // ç¢°æ’å¤„ç†
                        const angle = Math.atan2(dy, dx);
                        const sin = Math.sin(angle);
                        const cos = Math.cos(angle);
                        
                        // åˆ†ç¦»çƒ
                        const overlap = ball1.radius + ball2.radius - distance;
                        ball1.x -= overlap * 0.5 * cos;
                        ball1.y -= overlap * 0.5 * sin;
                        ball2.x += overlap * 0.5 * cos;
                        ball2.y += overlap * 0.5 * sin;
                        
                        // äº¤æ¢é€Ÿåº¦åˆ†é‡
                        const vx1 = ball1.vx * cos + ball1.vy * sin;
                        const vy1 = ball1.vy * cos - ball1.vx * sin;
                        const vx2 = ball2.vx * cos + ball2.vy * sin;
                        const vy2 = ball2.vy * cos - ball2.vx * sin;
                        
                        ball1.vx = vx2 * cos - vy1 * sin;
                        ball1.vy = vy1 * cos + vx2 * sin;
                        ball2.vx = vx1 * cos - vy2 * sin;
                        ball2.vy = vy2 * cos + vx1 * sin;
                        
                        // å‡å°‘èƒ½é‡
                        ball1.vx *= 0.9;
                        ball1.vy *= 0.9;
                        ball2.vx *= 0.9;
                        ball2.vy *= 0.9;
                    }
                }
            }
        }
        
        // æ£€æŸ¥æœ‰æ•ˆå‡»çƒ
        function checkValidShot(hitBall) {
            if (gamePhase === 'red' && hitBall.type === 'red') {
                // å‡»ä¸­çº¢çƒ
                setTimeout(() => {
                    if (!hitBall.isMoving()) {
                        hitBall.active = false;
                        playerScore += hitBall.points;
                        updateScore();
                        
                        // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰çº¢çƒ
                        const redBallsLeft = balls.filter(b => b.type === 'red' && b.active).length;
                        if (redBallsLeft === 0) {
                            gamePhase = 'color';
                            targetBall = 'é»„çƒ';
                        } else {
                            targetBall = 'å½©çƒ';
                        }
                        updateTargetBall();
                    }
                }, 1000);
            } else if (gamePhase === 'red' && hitBall.type === 'colored') {
                // çº¢çƒé˜¶æ®µå‡»ä¸­å½©çƒ
                setTimeout(() => {
                    if (!hitBall.isMoving()) {
                        playerScore += hitBall.points;
                        updateScore();
                        targetBall = 'çº¢çƒ';
                        updateTargetBall();
                        // å½©çƒå›åˆ°åŸä½ï¼ˆç®€åŒ–å¤„ç†ï¼‰
                    }
                }, 1000);
            } else if (gamePhase === 'color' && hitBall.type === 'colored') {
                // å½©çƒé˜¶æ®µæŒ‰é¡ºåºå‡»çƒ
                setTimeout(() => {
                    if (!hitBall.isMoving()) {
                        hitBall.active = false;
                        playerScore += hitBall.points;
                        updateScore();
                        updateNextColorTarget();
                    }
                }, 1000);
            }
        }
        
        // æ›´æ–°ä¸‹ä¸€ä¸ªå½©çƒç›®æ ‡
        function updateNextColorTarget() {
            const colorOrder = ['é»„çƒ', 'ç»¿çƒ', 'æ£•çƒ', 'è“çƒ', 'ç²‰çƒ', 'é»‘çƒ'];
            const currentIndex = colorOrder.indexOf(targetBall);
            if (currentIndex < colorOrder.length - 1) {
                targetBall = colorOrder[currentIndex + 1];
            } else {
                targetBall = 'æ¸¸æˆç»“æŸ';
            }
            updateTargetBall();
        }
        
        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScore() {
            document.getElementById('playerScore').textContent = playerScore;
            const redBallsLeft = balls.filter(b => b.type === 'red' && b.active).length;
            document.getElementById('redBalls').textContent = redBallsLeft;
        }
        
        // æ›´æ–°ç›®æ ‡çƒæ˜¾ç¤º
        function updateTargetBall() {
            document.getElementById('targetBall').textContent = targetBall;
        }
        
        // ç»˜åˆ¶ç„å‡†çº¿
        function drawAimLine() {
            if (isAiming) {
                ctx.beginPath();
                ctx.moveTo(cueBall.x, cueBall.y);
                ctx.lineTo(aimStartX, aimStartY);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // æ›´æ–°åŠ›åº¦æ˜¾ç¤º
                const dx = aimStartX - cueBall.x;
                const dy = aimStartY - cueBall.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                power = Math.min(100, (distance / 120) * 100);
                powerFill.style.width = power + '%';
                powerText.textContent = Math.round(power);
            }
        }
        
        // ç»˜åˆ¶çƒå°æ ‡è®°
        function drawTableMarks() {
            // DåŒºï¼ˆå‘çƒåŒºï¼‰
            ctx.beginPath();
            ctx.arc(200, 225, 80, -Math.PI/2, Math.PI/2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ä¸­çº¿
            ctx.beginPath();
            ctx.moveTo(450, 0);
            ctx.lineTo(450, canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ¡Œé¢
            ctx.fillStyle = '#0f5132';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶çƒå°æ ‡è®°
            drawTableMarks();
            
            // æ›´æ–°å’Œç»˜åˆ¶çƒ
            balls.forEach(ball => {
                ball.update();
                ball.draw();
            });
            
            // æ£€æµ‹ç¢°æ’
            checkCollisions();
            
            // ç»˜åˆ¶ç„å‡†çº¿
            drawAimLine();
            
            requestAnimationFrame(gameLoop);
        }
        
        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const dx = mouseX - cueBall.x;
            const dy = mouseY - cueBall.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰çƒéƒ½åœæ­¢äº†
            const allStopped = balls.every(ball => !ball.isMoving());
            
            if (distance <= cueBall.radius + 30 && allStopped && cueBall.active) {
                isAiming = true;
                aimStartX = mouseX;
                aimStartY = mouseY;
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isAiming) {
                const rect = canvas.getBoundingClientRect();
                aimStartX = e.clientX - rect.left;
                aimStartY = e.clientY - rect.top;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            if (isAiming) {
                const dx = aimStartX - cueBall.x;
                const dy = aimStartY - cueBall.y;
                const force = Math.min(power / 100, 1) * 12;
                
                cueBall.vx = (dx / 120) * force;
                cueBall.vy = (dy / 120) * force;
                
                isAiming = false;
                power = 0;
                powerFill.style.width = '0%';
                powerText.textContent = '0';
            }
        });
        
        // é‡ç½®æ¸¸æˆ
        function resetGame() {
            initBalls();
            playerScore = 0;
            gamePhase = 'red';
            targetBall = 'çº¢çƒ';
            isAiming = false;
            power = 0;
            powerFill.style.width = '0%';
            powerText.textContent = '0';
            updateScore();
            updateTargetBall();
        }
        
        // æ˜¾ç¤ºè§„åˆ™
        function showRules() {
            alert('åº·ä¹çƒæ¸¸æˆè§„åˆ™ï¼š\n\n1. å…ˆå‡»çº¢çƒï¼ˆ1åˆ†ï¼‰ï¼Œå†å‡»å½©çƒï¼ˆ2-7åˆ†ï¼‰\n2. çº¢çƒå‡»å…¥åä¸å†å›åˆ°å°é¢\n3. å½©çƒå‡»å…¥åå›åˆ°åŸä½ï¼ˆçº¢çƒé˜¶æ®µï¼‰\n4. çº¢çƒå…¨éƒ¨å‡»å®Œåï¼ŒæŒ‰åˆ†å€¼é¡ºåºå‡»å½©çƒ\n5. å½©çƒé¡ºåºï¼šé»„(2)â†’ç»¿(3)â†’æ£•(4)â†’è“(5)â†’ç²‰(6)â†’é»‘(7)\n6. ç›®æ ‡æ˜¯è·å¾—æœ€é«˜åˆ†æ•°');
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initBalls();
        updateScore();
        updateTargetBall();
        gameLoop();
    </script>
</body>
</html>