<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•…äº‹çŸ¥è¯†å›¾è°± - å‘é‡ç›¸ä¼¼åº¦å¯è§†åŒ–</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Microsoft YaHei', Arial, sans-serif; background: #f5f5f5; color: #333; overflow: hidden; }
        .container { width: 100vw; height: 100vh; position: relative; }
        .controls { position: absolute; top: 20px; left: 20px; z-index: 100; background: rgba(255,255,255,0.95); padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); width: 350px; }
        .controls h2 { margin-bottom: 15px; color: #2196F3; }
        .search-box { display: flex; gap: 10px; margin-bottom: 15px; }
        .search-box input { padding: 10px; border: 2px solid #ddd; border-radius: 5px; background: white; color: #333; width: 300px; }
        .search-box button { padding: 10px 20px; background: #2196F3; border: none; border-radius: 5px; cursor: pointer; color: white; font-weight: bold; }
        .search-box button:hover { background: #1976D2; }
        .top-n { margin-bottom: 10px; }
        .top-n label { display: block; margin-bottom: 5px; }
        .top-n input { width: 100px; padding: 5px; border: 2px solid #ddd; border-radius: 3px; background: white; color: #333; }
        .results { max-height: 200px; overflow-y: auto; }
        .result-item { background: rgba(33, 150, 243, 0.1); padding: 8px; margin: 5px 0; border-radius: 5px; font-size: 14px; border-left: 3px solid #2196F3; }
        #canvas { display: block; background: linear-gradient(135deg, #e3f2fd 0%, #f8f9fa 100%); }
        .legend { position: absolute; bottom: 20px; right: 20px; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .vector-table { position: absolute; top: 20px; left: 390px; z-index: 100; background: rgba(255,255,255,0.95); padding: 15px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); width: 600px; max-height: 80vh; overflow-y: auto; cursor: move; }
        .vector-table h3 { margin-bottom: 10px; color: #2196F3; display: flex; justify-content: space-between; align-items: center; }
        .vector-table table { width: 100%; border-collapse: collapse; font-size: 11px; }
        .vector-table th, .vector-table td { padding: 4px; border: 1px solid #ddd; text-align: center; }
        .vector-table th { background: #f5f5f5; font-weight: bold; }
        .vector-table .story-name { text-align: left; font-weight: bold; min-width: 40px; max-width: 80px; }
        .vector-table .matched { background: rgba(76, 175, 80, 0.1); }
        .vector-table .query-row { background: rgba(255, 87, 34, 0.1); }
        .collapse-btn { background: #2196F3; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px; }
        .collapsed { height: 40px; overflow: hidden; }
        .collapsed table { display: none; }
        #canvas { cursor: grab; }
        .legend-item { display: flex; align-items: center; margin: 5px 0; }
        .legend-color { width: 20px; height: 20px; border-radius: 50%; margin-right: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>ğŸ” æ•…äº‹å‘é‡æœç´¢</h2>
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="è¾“å…¥å…³é”®è¯æœç´¢ç›¸ä¼¼æ•…äº‹..." value="çˆ±æƒ…">
                <button onclick="searchStories()">æœç´¢</button>
            </div>
            <div class="top-n">
                <label>æ˜¾ç¤ºTOP Nä¸ªç›¸ä¼¼æ•…äº‹:</label>
                <input type="number" id="topN" value="5" min="1" max="10" onchange="searchStories()">
            </div>
            <div class="results" id="results"></div>
        </div>
        
        <canvas id="canvas"></canvas>
        
        <div class="vector-table">
            <h3>ğŸ“Š å‘é‡æ•°æ®è¡¨ <button class="collapse-btn" onclick="toggleTable()">æŠ˜å </button></h3>
            <div id="vectorTable"></div>
        </div>
        
        <div class="legend">
            <h3>å›¾ä¾‹</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #2196F3;"></div>
                <span>æ™®é€šæ•…äº‹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #4CAF50;"></div>
                <span>åŒ¹é…æ•…äº‹</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF5722;"></div>
                <span>æŸ¥è¯¢ç‚¹</span>
            </div>
        </div>
    </div>

    <script>
        const stories = [
            { name: "ç™½é›ªå…¬ä¸»", keywords: ["å…¬ä¸»", "é­”é•œ", "ä¸ƒä¸ªå°çŸ®äºº", "æ¯’è‹¹æœ", "å–„è‰¯", "ç¾ä¸½"] },
            { name: "ç°å§‘å¨˜", keywords: ["èˆä¼š", "æ°´æ™¶é‹", "å—ç“œé©¬è½¦", "ä»™å¥³", "ç‹å­", "çˆ±æƒ…"] },
            { name: "ç¡ç¾äºº", keywords: ["è¯…å’’", "çººé”¤", "æ²‰ç¡", "ç‹å­", "å»", "çˆ±æƒ…"] },
            { name: "å°çº¢å¸½", keywords: ["æ£®æ—", "ç‹¼", "å¥¶å¥¶", "çŒäºº", "å±é™©", "å‹‡æ•¢"] },
            { name: "ä¸‰åªå°çŒª", keywords: ["æˆ¿å­", "ç‹¼", "æ™ºæ…§", "å‹¤åŠ³", "å®‰å…¨", "å…„å¼Ÿ"] },
            { name: "ä¸‘å°é¸­", keywords: ["å¤©é¹…", "æˆé•¿", "è‡ªä¿¡", "ç¾ä¸½", "èœ•å˜", "åšæŒ"] },
            { name: "å°ç¾äººé±¼", keywords: ["æµ·æ´‹", "ç‹å­", "å£°éŸ³", "çˆ±æƒ…", "ç‰ºç‰²", "å‹‡æ•¢"] },
            { name: "é•¿å‘å…¬ä¸»", keywords: ["å¡”æ¥¼", "é•¿å‘", "ç‹å­", "å·«å©†", "è‡ªç”±", "çˆ±æƒ…"] },
            { name: "é’è›™ç‹å­", keywords: ["é’è›™", "å…¬ä¸»", "è¯ºè¨€", "å˜èº«", "è¯šä¿¡", "çˆ±æƒ…"] },
            { name: "æ‹‡æŒ‡å§‘å¨˜", keywords: ["èŠ±æœµ", "å°äºº", "æ—…è¡Œ", "åšå¼º", "å–„è‰¯", "æˆé•¿"] },
            { name: "å–ç«æŸ´çš„å°å¥³å­©", keywords: ["å¯’å†·", "ç«æŸ´", "å¹»æƒ³", "æ¸©æš–", "åŒæƒ…", "å¸Œæœ›"] },
            { name: "çš‡å¸çš„æ–°è£…", keywords: ["çš‡å¸", "éª—å­", "è™šè£", "çœŸç›¸", "å‹‡æ•¢", "è¯šå®"] },
            { name: "è±Œè±†å…¬ä¸»", keywords: ["è±Œè±†", "åºŠå«", "æ•æ„Ÿ", "çœŸå®", "è€ƒéªŒ", "é«˜è´µ"] },
            { name: "ç³–æœå±‹", keywords: ["æ£®æ—", "å·«å©†", "ç³–æœ", "å…„å¦¹", "æ™ºæ…§", "å‹‡æ•¢"] },
            { name: "é˜¿æ‹‰ä¸", keywords: ["ç¥ç¯", "ç²¾çµ", "æ„¿æœ›", "å…¬ä¸»", "å†’é™©", "çˆ±æƒ…"] },
            { name: "ç¾å¥³ä¸é‡å…½", keywords: ["é‡å…½", "ç¾å¥³", "è¯…å’’", "å†…åœ¨ç¾", "çˆ±æƒ…", "å®½å®¹"] },
            { name: "å°ç‹å­", keywords: ["æ˜Ÿçƒ", "ç«ç‘°", "ç‹ç‹¸", "å‹è°Š", "çº¯çœŸ", "æˆé•¿"] },
            { name: "åŒ¹è¯ºæ›¹", keywords: ["æœ¨å¶", "è¯´è°", "é¼»å­", "è¯šå®", "æˆé•¿", "çˆ¶çˆ±"] },
            { name: "æ°å…‹ä¸è±Œè±†", keywords: ["è±Œè±†", "å·¨äºº", "åŸå ¡", "å‹‡æ•¢", "å†’é™©", "æ™ºæ…§"] },
            { name: "é‡‘å‘å¥³å­©", keywords: ["ä¸‰åªç†Š", "æˆ¿å­", "å¥½å¥‡", "æ•™è®­", "å°Šé‡", "ç¤¼è²Œ"] },
            { name: "é™å¤œæ€", keywords: ["æœˆå…‰", "æ€ä¹¡", "å­¤ç‹¬", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "æ˜¥æ™“", keywords: ["æ˜¥å¤©", "ç¾ä¸½", "è‡ªç„¶", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "ç™»é¹³é›€æ¥¼", keywords: ["é«˜è¿œ", "æ™ºæ…§", "æˆé•¿", "ç¾ä¸½", "å¸Œæœ›"] },
            { name: "ç›¸æ€", keywords: ["çˆ±æƒ…", "æ€å¿µ", "ç¾ä¸½", "æ¸©æš–"] },
            { name: "å’é¹…", keywords: ["è‡ªç„¶", "ç¾ä¸½", "çº¯çœŸ", "æ¸©æš–"] },
            { name: "æ‚¯å†œ", keywords: ["å‹¤åŠ³", "å–„è‰¯", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "å¤æœ—æœˆè¡Œ", keywords: ["æœˆå…‰", "çº¯çœŸ", "ç¾ä¸½", "å¸Œæœ›"] },
            { name: "æœ›åºå±±ç€‘å¸ƒ", keywords: ["è‡ªç„¶", "ç¾ä¸½", "å£®è§‚", "å¸Œæœ›"] },
            { name: "æ—©å‘ç™½å¸åŸ", keywords: ["è‡ªç”±", "å¿«ä¹", "å¸Œæœ›", "ç¾ä¸½"] },
            { name: "é»„é¹¤æ¥¼é€å­Ÿæµ©ç„¶ä¹‹å¹¿é™µ", keywords: ["å‹è°Š", "ç¦»åˆ«", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "å›ä¹¡å¶ä¹¦", keywords: ["æ€ä¹¡", "æˆé•¿", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "å’æŸ³", keywords: ["æ˜¥å¤©", "ç¾ä¸½", "è‡ªç„¶", "å¸Œæœ›"] },
            { name: "å‡‰å·è¯", keywords: ["è¾¹å¡", "å‹‡æ•¢", "å£®å¿—", "å¸Œæœ›"] },
            { name: "å‡ºå¡", keywords: ["è¾¹å¡", "å‹‡æ•¢", "ä¿å«", "å¸Œæœ›"] },
            { name: "èŠ™è“‰æ¥¼é€è¾›æ¸", keywords: ["å‹è°Š", "ç¦»åˆ«", "è¯šå®", "æ¸©æš–"] },
            { name: "é¹¿æŸ´", keywords: ["è‡ªç„¶", "å®é™", "ç¾ä¸½", "å¸Œæœ›"] },
            { name: "é€å…ƒäºŒä½¿å®‰è¥¿", keywords: ["å‹è°Š", "ç¦»åˆ«", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "ä¹æœˆä¹æ—¥å¿†å±±ä¸œå…„å¼Ÿ", keywords: ["æ€ä¹¡", "äº²æƒ…", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "æœ›å¤©é—¨å±±", keywords: ["è‡ªç„¶", "å£®è§‚", "ç¾ä¸½", "å¸Œæœ›"] },
            { name: "åˆ«è‘£å¤§", keywords: ["å‹è°Š", "ç¦»åˆ«", "å‹‡æ•¢", "å¸Œæœ›"] },
            { name: "ç»å¥", keywords: ["æ˜¥å¤©", "è‡ªç„¶", "ç¾ä¸½", "å¸Œæœ›"] },
            { name: "æ˜¥å¤œå–œé›¨", keywords: ["æ˜¥å¤©", "è‡ªç„¶", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "ç»å¥äºŒé¦–", keywords: ["è‡ªç„¶", "ç¾ä¸½", "å®é™", "å¸Œæœ›"] },
            { name: "æ±Ÿç•”ç‹¬æ­¥å¯»èŠ±", keywords: ["æ˜¥å¤©", "ç¾ä¸½", "è‡ªç„¶", "å¸Œæœ›"] },
            { name: "æ¸¸å­åŸ", keywords: ["æ¯çˆ±", "äº²æƒ…", "æ¸©æš–", "å–„è‰¯"] },
            { name: "ç™»ä¹æ¸¸åŸ", keywords: ["å¤•é˜³", "ç¾ä¸½", "æ„Ÿæ…¨", "å¸Œæœ›"] },
            { name: "å¯»éšè€…ä¸é‡", keywords: ["è‡ªç„¶", "å®é™", "å¯»æ‰¾", "å¸Œæœ›"] },
            { name: "æ«æ¡¥å¤œæ³Š", keywords: ["å¤œæ™š", "æ€ä¹¡", "å®é™", "æ¸©æš–"] },
            { name: "æ¸”æ­Œå­", keywords: ["è‡ªç„¶", "è‡ªç”±", "å®é™", "å¸Œæœ›"] },
            { name: "å¡ä¸‹æ›²", keywords: ["è¾¹å¡", "å‹‡æ•¢", "æˆ˜æ–—", "å¸Œæœ›"] },
            { name: "æœ›æ´åº­", keywords: ["è‡ªç„¶", "ç¾ä¸½", "å®é™", "å¸Œæœ›"] },
            { name: "æµªæ·˜æ²™", keywords: ["è‡ªç„¶", "å£®è§‚", "ç¾ä¸½", "å¸Œæœ›"] },
            { name: "èµ‹å¾—å¤åŸè‰é€åˆ«", keywords: ["è‡ªç„¶", "ç¦»åˆ«", "å‹è°Š", "å¸Œæœ›"] },
            { name: "æ± ä¸Š", keywords: ["ç«¥è¶£", "çº¯çœŸ", "è‡ªç„¶", "æ¸©æš–"] },
            { name: "å¿†æ±Ÿå—", keywords: ["æ±Ÿå—", "ç¾ä¸½", "æ€å¿µ", "æ¸©æš–"] },
            { name: "å°å„¿å‚é’“", keywords: ["ç«¥è¶£", "çº¯çœŸ", "è‡ªç„¶", "æ¸©æš–"] },
            { name: "æ‚¯å†œäºŒé¦–", keywords: ["å‹¤åŠ³", "å–„è‰¯", "çæƒœ", "æ¸©æš–"] },
            { name: "å±±è¡Œ", keywords: ["ç§‹å¤©", "è‡ªç„¶", "ç¾ä¸½", "å¸Œæœ›"] },
            { name: "æ¸…æ˜", keywords: ["æ˜¥å¤©", "æ€å¿µ", "æ¸©æš–", "å¸Œæœ›"] },
            { name: "æ±Ÿå—æ˜¥", keywords: ["æ±Ÿå—", "æ˜¥å¤©", "ç¾ä¸½", "æ¸©æš–"] },
            { name: "ä¹æ¸¸åŸ", keywords: ["å¤•é˜³", "ç¾ä¸½", "æ„Ÿæ…¨", "å¸Œæœ›"] },
            { name: "é¢˜è¥¿æ—å£", keywords: ["å±±æ°´", "æ™ºæ…§", "å“²ç†", "å¸Œæœ›"] },
            { name: "å¤æ—¥ç»å¥", keywords: ["è‹±é›„", "å‹‡æ•¢", "æ°”èŠ‚", "å¸Œæœ›"] },
            { name: "ç¤ºå„¿", keywords: ["çˆ±å›½", "å¸Œæœ›", "æ¸©æš–", "å‹‡æ•¢"] },
            { name: "ç§‹å¤œå°†æ™“å‡ºç¯±é—¨è¿å‡‰æœ‰æ„Ÿ", keywords: ["çˆ±å›½", "å¿§è™‘", "å¸Œæœ›", "æ¸©æš–"] },
            { name: "å››æ—¶ç”°å›­æ‚å…´", keywords: ["ç”°å›­", "è‡ªç„¶", "å‹¤åŠ³", "æ¸©æš–"] },
            { name: "å°æ± ", keywords: ["å¤å¤©", "è‡ªç„¶", "ç¾ä¸½", "çº¯çœŸ"] },
            { name: "æ™“å‡ºå‡€æ…ˆå¯ºé€æ—å­æ–¹", keywords: ["å¤å¤©", "ç¾ä¸½", "å‹è°Š", "æ¸©æš–"] },
            { name: "æ˜¥æ—¥", keywords: ["æ˜¥å¤©", "ç¾ä¸½", "æ™ºæ…§", "å¸Œæœ›"] },
            { name: "é¢˜ä¸´å®‰é‚¸", keywords: ["å¿§å›½", "è®½åˆº", "å¸Œæœ›", "å‹‡æ•¢"] },
            { name: "æ¸¸å›­ä¸å€¼", keywords: ["æ˜¥å¤©", "ç¾ä¸½", "å¸Œæœ›", "è‡ªç„¶"] },
            { name: "ä¹¡æ‘å››æœˆ", keywords: ["ç”°å›­", "å‹¤åŠ³", "è‡ªç„¶", "æ¸©æš–"] }
        ];

        let canvas, ctx, animationId;
        let storyNodes = [];
        let queryNode = null;
        let matchedStories = [];
        let canvasOffset = { x: 0, y: 0 };
        let canvasScale = 1;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let isTableDragging = false;
        let tableDragStart = { x: 0, y: 0 };
        let tablePosition = { x: 390, y: 20 };

        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            generateStoryNodes();
            updateVectorTable();
            animate();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseout', handleMouseOut);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('wheel', handleCanvasWheel);
            
            const vectorTable = document.querySelector('.vector-table');
            vectorTable.addEventListener('mousedown', handleTableMouseDown);
            document.addEventListener('mousemove', handleDocumentMouseMove);
            document.addEventListener('mouseup', handleDocumentMouseUp);
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // BGEæ¨¡æ‹Ÿå‘é‡ç”Ÿæˆ
        function generateBGEVector(text) {
            // æ¨¡æ‹ŸBGE embeddingçš„768ç»´å‘é‡
            const vector = [];
            const textHash = text.split('').reduce((hash, char) => {
                return ((hash << 5) - hash + char.charCodeAt(0)) & 0xffffffff;
            }, 0);
            
            for (let i = 0; i < 32; i++) {
                const seed = textHash + i * 1000;
                vector.push(Math.sin(seed) * 0.5 + 0.5);
            }
            return vector;
        }
        
        // K-meansèšç±»
        function kMeansCluster(nodes, k = 5) {
            const vectors = nodes.map(node => node.vector);
            let centroids = [];
            
            // åˆå§‹åŒ–èšç±»ä¸­å¿ƒ
            for (let i = 0; i < k; i++) {
                centroids.push(vectors[Math.floor(Math.random() * vectors.length)].slice());
            }
            
            for (let iter = 0; iter < 10; iter++) {
                const clusters = Array(k).fill().map(() => []);
                
                // åˆ†é…èŠ‚ç‚¹åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
                nodes.forEach((node, idx) => {
                    let minDist = Infinity;
                    let clusterIdx = 0;
                    
                    centroids.forEach((centroid, i) => {
                        const dist = euclideanDistance(node.vector, centroid);
                        if (dist < minDist) {
                            minDist = dist;
                            clusterIdx = i;
                        }
                    });
                    
                    clusters[clusterIdx].push(idx);
                    node.cluster = clusterIdx;
                });
                
                // æ›´æ–°èšç±»ä¸­å¿ƒ
                clusters.forEach((cluster, i) => {
                    if (cluster.length > 0) {
                        const newCentroid = Array(vectors[0].length).fill(0);
                        cluster.forEach(nodeIdx => {
                            vectors[nodeIdx].forEach((val, j) => {
                                newCentroid[j] += val;
                            });
                        });
                        newCentroid.forEach((val, j) => {
                            centroids[i][j] = val / cluster.length;
                        });
                    }
                });
            }
            
            return nodes;
        }
        
        function euclideanDistance(vec1, vec2) {
            return Math.sqrt(vec1.reduce((sum, val, i) => sum + Math.pow(val - vec2[i], 2), 0));
        }
        
        const clusterColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF', '#5F27CD'];

        function cosineSimilarity(vec1, vec2) {
            const dotProduct = vec1.reduce((sum, a, i) => sum + a * vec2[i], 0);
            const magnitude1 = Math.sqrt(vec1.reduce((sum, a) => sum + a * a, 0));
            const magnitude2 = Math.sqrt(vec2.reduce((sum, a) => sum + a * a, 0));
            return dotProduct / (magnitude1 * magnitude2);
        }

        function generateStoryNodes() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.35;

            storyNodes = stories.map((story, index) => {
                const text = story.name + ' ' + story.keywords.join(' ');
                const vector = generateBGEVector(text);
                
                return {
                    ...story,
                    vector,
                    baseX: 0,
                    baseY: 0,
                    x: 0,
                    y: 0,
                    isMatched: false,
                    similarity: 0,
                    cluster: 0
                };
            });
            
            // æ‰§è¡Œèšç±»
            kMeansCluster(storyNodes, 6);
            
            // ä½¿ç”¨t-SNEé™ç»´å¸ƒå±€
            layoutNodesByTSNE();
        }
        
        function layoutNodesByTSNE() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // ç®€åŒ–çš„t-SNEå¸ƒå±€
            storyNodes.forEach((node, i) => {
                const clusterAngle = (node.cluster * 2 * Math.PI) / 6;
                const clusterRadius = 200;
                const nodeAngle = (i * 2 * Math.PI) / storyNodes.length;
                const nodeRadius = 50 + Math.random() * 100;
                
                node.baseX = centerX + Math.cos(clusterAngle) * clusterRadius + Math.cos(nodeAngle) * nodeRadius;
                node.baseY = centerY + Math.sin(clusterAngle) * clusterRadius + Math.sin(nodeAngle) * nodeRadius;
                node.x = node.baseX;
                node.y = node.baseY;
            });
        }

        function searchStories() {
            const query = document.getElementById('searchInput').value.trim();
            const topN = parseInt(document.getElementById('topN').value);
            
            if (!query) {
                matchedStories = [];
                queryNode = null;
                storyNodes.forEach(node => node.isMatched = false);
                updateResults([]);
                return;
            }

            const queryVector = generateBGEVector(query);
            
            // è®¡ç®—ç›¸ä¼¼åº¦
            storyNodes.forEach(node => {
                node.similarity = cosineSimilarity(queryVector, node.vector);
                node.isMatched = false;
            });

            // æ’åºå¹¶é€‰æ‹©TOP N
            const sortedStories = [...storyNodes].sort((a, b) => b.similarity - a.similarity);
            matchedStories = sortedStories.slice(0, topN);
            matchedStories.forEach(story => story.isMatched = true);

            // åˆ›å»ºæŸ¥è¯¢èŠ‚ç‚¹
            queryNode = {
                name: `æŸ¥è¯¢: ${query}`,
                vector: queryVector,
                baseX: canvas.width / 2,
                baseY: canvas.height / 2,
                x: canvas.width / 2,
                y: canvas.height / 2,
                cluster: -1
            };

            updateResults(matchedStories);
            updateVectorTable();
        }

        function updateResults(results) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = results.map((story, index) => 
                `<div class="result-item">${index + 1}. ${story.name} (ç›¸ä¼¼åº¦: ${(story.similarity * 100).toFixed(1)}%)</div>`
            ).join('');
        }
        
        function updateVectorTable() {
            const tableDiv = document.getElementById('vectorTable');
            let html = '<table><thead><tr><th class="story-name">åç§°</th><th>ç±»åˆ«</th>';
            for (let i = 0; i < 16; i++) {
                html += `<th>V${i}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            if (queryNode) {
                html += '<tr class="query-row"><td class="story-name">' + queryNode.name + '</td><td>æŸ¥è¯¢</td>';
                queryNode.vector.slice(0, 16).forEach(value => {
                    html += `<td>${value.toFixed(3)}</td>`;
                });
                html += '</tr>';
            }
            
            storyNodes.forEach(node => {
                const rowClass = node.isMatched ? 'matched' : '';
                html += `<tr class="${rowClass}"><td class="story-name">${node.name}</td><td style="color: ${clusterColors[node.cluster]}">ç±»${node.cluster + 1}</td>`;
                node.vector.slice(0, 16).forEach(value => {
                    html += `<td>${value.toFixed(3)}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            tableDiv.innerHTML = html;
        }

        function drawNode(node, color, size = 8) {
            const scaledSize = size * canvasScale;
            const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, scaledSize);
            gradient.addColorStop(0, color);
            gradient.addColorStop(1, color + '80');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(node.x, node.y, scaledSize, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.shadowColor = color;
            ctx.shadowBlur = 15 * canvasScale;
            ctx.beginPath();
            ctx.arc(node.x, node.y, scaledSize * 0.6, 0, 2 * Math.PI);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawConnection(from, to, opacity = 0.3) {
            ctx.strokeStyle = `rgba(33, 150, 243, ${opacity})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();
        }

        function drawLabel(node, color = '#333') {
            ctx.fillStyle = color;
            ctx.font = `${12 * canvasScale}px Microsoft YaHei`;
            ctx.textAlign = 'center';
            ctx.fillText(node.name, node.x, node.y - 15 * canvasScale);
        }
        
        let hoveredNode = null;
        let tooltip = null;
        
        function handleMouseMove(event) {
            if (isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            hoveredNode = null;
            for (let node of storyNodes) {
                const distance = Math.sqrt((mouseX - node.x) ** 2 + (mouseY - node.y) ** 2);
                if (distance <= 15 * canvasScale) {
                    hoveredNode = node;
                    showTooltip(event.clientX, event.clientY, node);
                    return;
                }
            }
            
            if (queryNode) {
                const distance = Math.sqrt((mouseX - queryNode.x) ** 2 + (mouseY - queryNode.y) ** 2);
                if (distance <= 15 * canvasScale) {
                    hoveredNode = queryNode;
                    showTooltip(event.clientX, event.clientY, queryNode);
                    return;
                }
            }
            
            hideTooltip();
        }
        
        function handleMouseOut() {
            hoveredNode = null;
            hideTooltip();
        }
        
        function showTooltip(x, y, node) {
            hideTooltip();
            tooltip = document.createElement('div');
            tooltip.style.cssText = `
                position: fixed;
                left: ${x + 10}px;
                top: ${y - 10}px;
                background: rgba(255,255,255,0.95);
                border: 2px solid #2196F3;
                border-radius: 8px;
                padding: 12px;
                font-size: 12px;
                color: #333;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                max-width: 300px;
            `;
            
            const vectorStr = node.vector.slice(0, 8).map((v, i) => `V${i}: ${v.toFixed(3)}`).join('<br>');
            tooltip.innerHTML = `
                <strong>${node.name}</strong><br>
                <hr style="margin: 8px 0; border: 1px solid #eee;">
                <strong>å‘é‡å€¼:</strong><br>
                ${vectorStr}
            `;
            
            document.body.appendChild(tooltip);
        }
        
        function hideTooltip() {
            if (tooltip) {
                document.body.removeChild(tooltip);
                tooltip = null;
            }
        }
        
        function toggleTable() {
            const table = document.querySelector('.vector-table');
            table.classList.toggle('collapsed');
        }
        
        function handleCanvasMouseDown(event) {
            isDragging = true;
            dragStart.x = event.clientX - canvasOffset.x;
            dragStart.y = event.clientY - canvasOffset.y;
            canvas.style.cursor = 'grabbing';
        }
        
        function handleCanvasMouseUp() {
            isDragging = false;
            canvas.style.cursor = 'grab';
        }
        
        function handleCanvasWheel(event) {
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            const zoom = event.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.1, Math.min(3, canvasScale * zoom));
            
            canvasOffset.x = mouseX - (mouseX - canvasOffset.x) * (newScale / canvasScale);
            canvasOffset.y = mouseY - (mouseY - canvasOffset.y) * (newScale / canvasScale);
            canvasScale = newScale;
            
            updateNodePositions();
        }
        
        function handleTableMouseDown(event) {
            if (event.target.closest('.collapse-btn')) return;
            isTableDragging = true;
            tableDragStart.x = event.clientX - tablePosition.x;
            tableDragStart.y = event.clientY - tablePosition.y;
            event.preventDefault();
        }
        
        function handleDocumentMouseMove(event) {
            if (isDragging) {
                canvasOffset.x = event.clientX - dragStart.x;
                canvasOffset.y = event.clientY - dragStart.y;
                updateNodePositions();
            }
            
            if (isTableDragging) {
                tablePosition.x = event.clientX - tableDragStart.x;
                tablePosition.y = event.clientY - tableDragStart.y;
                const table = document.querySelector('.vector-table');
                table.style.left = tablePosition.x + 'px';
                table.style.top = tablePosition.y + 'px';
            }
        }
        
        function handleDocumentMouseUp() {
            isDragging = false;
            isTableDragging = false;
            canvas.style.cursor = 'grab';
        }
        
        function updateNodePositions() {
            storyNodes.forEach(node => {
                node.x = (node.baseX + canvasOffset.x) * canvasScale;
                node.y = (node.baseY + canvasOffset.y) * canvasScale;
            });
            
            if (queryNode) {
                queryNode.x = (queryNode.baseX + canvasOffset.x) * canvasScale;
                queryNode.y = (queryNode.baseY + canvasOffset.y) * canvasScale;
            }
        }
        
        function drawClusterConnections() {
            const clusters = {};
            storyNodes.forEach(node => {
                if (!clusters[node.cluster]) clusters[node.cluster] = [];
                clusters[node.cluster].push(node);
            });
            
            Object.values(clusters).forEach(clusterNodes => {
                if (clusterNodes.length > 1) {
                    for (let i = 0; i < clusterNodes.length; i++) {
                        for (let j = i + 1; j < clusterNodes.length; j++) {
                            const similarity = cosineSimilarity(clusterNodes[i].vector, clusterNodes[j].vector);
                            if (similarity > 0.7) {
                                ctx.strokeStyle = `rgba(200, 200, 200, ${similarity * 0.3})`;
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(clusterNodes[i].x, clusterNodes[i].y);
                                ctx.lineTo(clusterNodes[j].x, clusterNodes[j].y);
                                ctx.stroke();
                            }
                        }
                    }
                }
            });
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆå¦‚æœæœ‰æŸ¥è¯¢èŠ‚ç‚¹ï¼‰
            if (queryNode) {
                matchedStories.forEach(story => {
                    drawConnection(queryNode, story, story.similarity * 0.8);
                });
            }
            
            // ç»˜åˆ¶èšç±»è¿æ¥çº¿
            drawClusterConnections();
            
            // ç»˜åˆ¶æ•…äº‹èŠ‚ç‚¹
            storyNodes.forEach(node => {
                let color = clusterColors[node.cluster] || '#2196F3';
                if (node.isMatched) {
                    color = '#4CAF50';
                }
                const size = hoveredNode === node ? 12 : 8;
                drawNode(node, color, size);
                drawLabel(node, '#333');
            });
            
            // ç»˜åˆ¶æŸ¥è¯¢èŠ‚ç‚¹
            if (queryNode) {
                const size = hoveredNode === queryNode ? 16 : 12;
                drawNode(queryNode, '#FF5722', size);
                drawLabel(queryNode, '#333');
            }
            
            animationId = requestAnimationFrame(animate);
        }

        // åˆå§‹åŒ–
        window.addEventListener('load', init);
    </script>
</body>
</html>